//
// Copyright (C) 2019-2022 Pablo Delgado Kr√§mer
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.
//

#include "MtlxDocumentPatcher.h"

#include <MaterialXCore/Types.h>
#include <MaterialXFormat/File.h>
#include <MaterialXFormat/Util.h>

#include <unordered_set>
#include <assert.h>
#include <ctype.h>

#include <gtl/gb/Fmt.h>
#include <gtl/gb/Log.h>

namespace mx = MaterialX;

const char* TYPE_COLOR3 = "color3";
const char* TYPE_VECTOR3 = "vector3";
const char* TYPE_FLOAT = "float";
const char* TYPE_BOOL = "boolean";

const char* ENVVAR_DISABLE_USDUVTEXTURE_COLOR_SPACE_PATCHING =
  "GTL_DISABLE_MTLX_USDUVTEXTURE_COLOR_SPACE_PATCHING";

void _SanitizeFilePath(std::string& path)
{
  // The MDL SDK does not take raw OS paths. First, only forward-facing slashes are allowed.
  std::replace(path.begin(), path.end(), '\\', '/');

  // Second, only UNIX-style absolute paths ('/' prefix, no double colon) are valid.
  bool hasDriveSpecifier = path.size() >= 2 && path[1] == ':';

  if (hasDriveSpecifier)
  {
    path[1] = path[0];
    path[0] = '/';
  }
}

void _SanitizeFilePaths(mx::DocumentPtr document)
{
  for (auto treeIt = document->traverseTree(); treeIt != mx::TreeIterator::end(); ++treeIt)
  {
    mx::ElementPtr elem = treeIt.getElement();

    mx::PortElementPtr portElem = elem->asA<mx::PortElement>();
    if (!portElem)
    {
      continue;
    }

    std::string portType = portElem->getType();
    if (portType != mx::FILENAME_TYPE_STRING)
    {
      continue;
    }

    mx::ValuePtr valuePtr = portElem->getValue();
    if (!valuePtr)
    {
      continue;
    }

    std::string path = valuePtr->asA<std::string>();

    _SanitizeFilePath(path);

    portElem->setValue(path, mx::FILENAME_TYPE_STRING);
  }
}

mx::PortElementPtr _GetPortInterface(mx::PortElementPtr port)
{
  mx::ElementPtr parent = port->getParent();
  if (!parent)
  {
    return nullptr;
  }

  mx::NodePtr node = parent->asA<mx::Node>();
  if (!node)
  {
    return nullptr;
  }

  mx::NodeDefPtr nodeDef = node->getNodeDef(mx::EMPTY_STRING, true);
  if (!nodeDef)
  {
    return nullptr;
  }

  return nodeDef->getChildOfType<mx::PortElement>(port->getName());
}

std::string _GetPortType(mx::PortElementPtr port)
{
  mx::PortElementPtr portInterface = _GetPortInterface(port);

  return portInterface ? portInterface->getType() : port->getType();
}

void _PatchBoolValueMismatches(mx::DocumentPtr document)
{
  for (auto treeIt = document->traverseTree(); treeIt != mx::TreeIterator::end(); ++treeIt)
  {
    mx::ElementPtr elem = treeIt.getElement();

    mx::InputPtr input = elem->asA<mx::Input>();

    if (!input || input->getType() != TYPE_BOOL)
    {
      continue;
    }

    const mx::ValuePtr& value = input->getValue();
    if (!value || !value->isA<int>())
    {
      return;
    }

    input->setValue(bool(value->asA<int>()));
  }
}

// Workaround for an implicit type conversion issue between vector3 and color3 that occurs in code
// generated by the MDL backend: https://github.com/AcademySoftwareFoundation/MaterialX/issues/1038
//
// This issue does not only exist due to the mentioned UsdPreviewSurface issue, but has also been
// observed in the wild for the original OpenChessSet asset. We thus not only patch the UsdShade network,
// but also the MaterialX document.
//
// Additionally, implicit float -> color3 conversion has been observed in Karma networks.
void _PatchColor3FloatMismatches(mx::DocumentPtr document)
{
  for (auto treeIt = document->traverseTree(); treeIt != mx::TreeIterator::end(); ++treeIt)
  {
    mx::ElementPtr elem = treeIt.getElement();

    mx::InputPtr input = elem->asA<mx::Input>();
    if (!input)
    {
      continue;
    }

    mx::OutputPtr output = input->getConnectedOutput();
    if (!output)
    {
      continue;
    }

    bool isPatchable = (_GetPortType(input) == TYPE_COLOR3 && _GetPortType(output) == TYPE_VECTOR3) ||
                       (_GetPortType(input) == TYPE_VECTOR3 && _GetPortType(output) == TYPE_COLOR3) ||
                       (_GetPortType(input) == TYPE_COLOR3 && _GetPortType(output) == TYPE_FLOAT) ||
                       (_GetPortType(input) == TYPE_VECTOR3 && _GetPortType(output) == TYPE_FLOAT);

    if (!isPatchable)
    {
      return;
    }

    std::string nodeCategory = "convert";
    std::string nodeName = mx::EMPTY_STRING; // auto-assign
    std::string nodeType = (_GetPortType(input) == TYPE_COLOR3) ? TYPE_COLOR3 : TYPE_VECTOR3;
    mx::NodePtr node = document->addNode(nodeCategory, nodeName, nodeType);

    mx::InputPtr convertInput = node->addInput("in");
    convertInput->setConnectedOutput(output);

    // Can't clear because we need to preserve other attributes like 'colorspace'.
    input->removeAttribute(mx::PortElement::OUTPUT_ATTRIBUTE);
    input->removeAttribute(mx::PortElement::NODE_GRAPH_ATTRIBUTE);
    input->setType(nodeType);
    input->setConnectedNode(node);
  }
}

// This function serves two purposes: first, for USD versions below 23.11, we
// translate the 'sourceColorSpace' input to actual MaterialX colorspaces (this
// input is not part of the NodeDef, but we add it in the render delegate and
// HdMtlx permissively forwards it).
//
// The second purpose is to overwrite the 'auto' colorspace (which is the default
// if none other has been explicitly set) with an appropriate colorspace based on
// the image's usage.
void _PatchUsdUVTextureColorSpaces(mx::DocumentPtr document)
{
  for (auto treeIt = document->traverseTree(); treeIt != mx::TreeIterator::end(); ++treeIt)
  {
    mx::ElementPtr elem = treeIt.getElement();

    mx::InputPtr textureInput = elem->asA<mx::Input>();
    if (!textureInput || textureInput->hasColorSpace())
    {
      continue;
    }

    mx::ElementPtr upstreamElem = textureInput->getParent();
    mx::NodePtr downstreamNode = textureInput->getConnectedNode();
    if (!upstreamElem || !downstreamNode || downstreamNode->hasColorSpace())
    {
      continue;
    }

    mx::NodePtr upstreamNode = upstreamElem->asA<mx::Node>();
    if (!upstreamNode)
    {
      continue;
    }

    const mx::string& downstreamCategory = downstreamNode->getCategory();
    if (downstreamCategory != "UsdUVTexture")
    {
      continue;
    }

    mx::InputPtr colorSpaceInput = downstreamNode->getActiveInput("sourceColorSpace");
    mx::string textureInputName = textureInput->getName();

    std::string colorSpaceString = colorSpaceInput ? colorSpaceInput->getValueString() : "auto";

    const mx::string& upstreamCategory = upstreamNode->getCategory();
    bool isUpstreamUsdPreviewSurface = (upstreamCategory == "UsdPreviewSurface");

    bool isUsdPreviewSurfaceSrgbInput = isUpstreamUsdPreviewSurface &&
      (textureInputName == "diffuseColor" || textureInputName == "emissiveColor" || textureInputName == "specularColor");

    // Not spec-conform but should be more correct in most cases.
    bool isSrgbColorSpace = (colorSpaceString == "sRGB") || (colorSpaceString == "auto" && isUsdPreviewSurfaceSrgbInput);

    textureInput->setColorSpace(isSrgbColorSpace ? "srgb_texture" : "lin_rec709");

    // Prevent any other kind of processing.
    if (colorSpaceInput)
    {
      downstreamNode->removeInput(colorSpaceInput->getName());
    }
  }
}

// MDL spec 1.7.2 17th Jan 2022, section 5.6
std::unordered_set<std::string_view> s_reservedMDLIdentifiers = {
  "annotation", "auto", "bool", "bool2", "bool3", "bool4", "break", "bsdf",
  "bsdf_measurement", "case", "cast", "color", "const", "continue", "default",
  "do", "double", "double2", "double2x2", "double2x3", "double3", "double3x2",
  "double3x3", "double3x4", "double4", "double4x3", "double4x4", "double4x2",
  "double2x4", "edf", "else", "enum", "export", "false", "float", "float2",
  "float2x2", "float2x3", "float3", "float3x2", "float3x3", "float3x4",
  "float4", "float4x3", "float4x4", "float4x2", "float2x4", "for", "hair_bsdf",
  "if", "import", "in", "int", "int2", "int3", "int4", "intensity_mode",
  "intensity_power", "intensity_radiant_exitance", "let", "light_profile",
  "material", "material_emission", "material_geometry", "material_surface",
  "material_volume", "mdl", "module", "package", "return", "string", "struct",
  "switch", "texture_2d", "texture_3d", "texture_cube", "texture_ptex", "true",
  "typedef", "uniform", "using", "varying", "vdf", "while", "catch", "char",
  "class", "const_cast", "delete", "dynamic_cast", "explicit", "extern",
  "external", "foreach", "friend", "goto", "graph", "half", "half2", "half2x2",
  "half2x3", "half3", "half3x2", "half3x3", "half3x4", "half4", "half4x3",
  "half4x4", "half4x2", "half2x4", "inline", "inout", "lambda", "long",
  "mutable", "namespace", "native", "new", "operator", "out", "phenomenon",
  "private", "protected", "public", "reinterpret_cast", "sampler", "shader",
  "short", "signed", "sizeof", "static", "static_cast", "technique", "template",
  "this", "throw", "try", "typeid", "typename", "union", "unsigned", "virtual",
  "void", "volatile", "wchar_t"
};

// MDL spec section 5.5 and 5.6: "An identifier is an alphabetic character followed
// by a possibly empty sequence of alphabetic characters, decimal digits, and underscores,
// that is neither a typename nor a reserved word."
// https://raytracing-docs.nvidia.com/mdl/specification/MDL_spec_1.7.2_17Jan2022.pdf
bool _MakeValidMDLIdentifier(std::string& str)
{
  assert(!str.empty());
  bool strChanged = false;

  // Replace all chars that are not 1) alphabetic or 2) decimal or 3) underscores with underscores
  for (size_t i = 0; i < str.size(); i++)
  {
    char c = str[i];

    if (isalnum(c) || c == '_')
    {
      continue;
    }

    str[i] = '_';
    strChanged |= true;
  }

  bool invalidFirstChar = !isalpha(str[0]);
  bool isReservedKeyword = s_reservedMDLIdentifiers.find(str) != s_reservedMDLIdentifiers.end();

  bool usePrefix = invalidFirstChar || isReservedKeyword;
  if (usePrefix)
  {
    str = GB_FMT("GAT{}", str);
    strChanged |= true;
  }

  return strChanged;
}

void _PatchNodeNames(mx::DocumentPtr document)
{
  for (auto treeIt = document->traverseTree(); treeIt != mx::TreeIterator::end(); ++treeIt)
  {
    mx::ElementPtr elem = treeIt.getElement();

    mx::NodePtr node = elem->asA<mx::Node>();
    if (!node)
    {
      continue;
    }

    std::string newName = node->getName();

    if (!_MakeValidMDLIdentifier(newName))
    {
      continue;
    }

    std::string oldName = node->getName();

    // FIXME: this 'node renaming' algorithm works, but is not likely to cover all cases.
    // Ideally, there should a MaterialX library function for this purpose.
    for (mx::NodeGraphPtr nodeGraph : document->getNodeGraphs())
    {
      for (mx::OutputPtr output : nodeGraph->getOutputs())
      {
        if (output->getConnectedNode() == node)
        {
          output->setNodeName(newName);
        }
      }
    }
    for (mx::OutputPtr output : node->getOutputs())
    {
      if (output->getNodeName() == oldName)
      {
        output->setNodeName(newName);
      }
    }

    node->setName(newName);
  }
}

void _PatchSecondaryTexcoordIndices(mx::DocumentPtr document)
{
  for (auto treeIt = document->traverseTree(); treeIt != mx::TreeIterator::end(); ++treeIt)
  {
    mx::ElementPtr elem = treeIt.getElement();

    mx::NodePtr node = elem->asA<mx::Node>();
    if (!node || node->getCategory() != "texcoord")
    {
      continue;
    }

    mx::InputPtr indexInput = node->getActiveInput("index");
    if( !indexInput)
    {
      continue;
    }

    mx::ValuePtr boxedIndex = indexInput->getValue();
    if (!boxedIndex || !boxedIndex->isA<int>())
    {
      continue;
    }

    int index = boxedIndex->asA<int>();
    if (index == 0)
    {
      continue;
    }

    node->setCategory("geompropvalue");

    for (mx::InputPtr input : node->getInputs())
    {
      node->removeInput(input->getName());
    }

    mx::InputPtr geompropInput = node->addInput("geomprop", mx::FILENAME_TYPE_STRING);

    std::string primvarName = GB_FMT("st{}", index);
    geompropInput->setValueString(primvarName);

    GB_WARN("texcoord node \"{}\" has unsupported index {}; patching to geompropvalue of \"{}\"",
      node->getNamePath(), index, primvarName);
  }
}

void _PatchColorNodes(mx::DocumentPtr document)
{
  for (auto treeIt = document->traverseTree(); treeIt != mx::TreeIterator::end(); ++treeIt)
  {
    mx::ElementPtr elem = treeIt.getElement();

    mx::NodePtr node = elem->asA<mx::Node>();
    if (!node)
    {
      continue;
    }

    const mx::string& category = node->getCategory();
    if (category != "color")
    {
      continue;
    }

    node->setCategory("geompropvalue");
    node->setType(TYPE_COLOR3); // FIXME: hook up displayOpacity if type is color4

    for (mx::InputPtr input : node->getInputs())
    {
      node->removeInput(input->getName());
    }

    mx::InputPtr geompropInput = node->addInput("geomprop", mx::FILENAME_TYPE_STRING);

    std::string primvarName = "displayColor";
    geompropInput->setValueString(primvarName);

    GB_WARN("replaced color node \"{}\" with geompropvalue of \"{}\"",
      node->getNamePath(), primvarName);
  }
}

// We're guaranteed to use st/st0/UV0 as texture coordinates in our vertex data, so prefer
// this to explicitly sampling a primvar for performance reasons.
void _PatchDefaultGeomprops(mx::DocumentPtr document)
{
  for (auto treeIt = document->traverseTree(); treeIt != mx::TreeIterator::end(); ++treeIt)
  {
    mx::ElementPtr elem = treeIt.getElement();

    mx::NodePtr node = elem->asA<mx::Node>();
    if (!node)
    {
      continue;
    }

    const mx::string& category = node->getCategory();

    if (category != "geompropvalue")
    {
      continue;
    }

    mx::InputPtr input = node->getActiveInput("geomprop");
    if( !input)
    {
      continue;
    }

    mx::ValuePtr value = input->getValue();
    if (!value || !value->isA<std::string>())
    {
      continue;
    }

    std::string geomprop = value->asA<std::string>();

    bool isTexcoord = geomprop == "st" ||
                      geomprop == "st0" ||
                      geomprop == "st_0" ||
                      geomprop == "map1" ||
                      geomprop == "UV0";

    bool isTangent = (geomprop == "tangents");

    if (!isTexcoord && !isTangent)
    {
      continue;
    }

    for (mx::InputPtr i : node->getInputs())
    {
      node->removeInput(i->getName());
    }

    node->setCategory(isTexcoord ? "texcoord" : "tangent");
  }
}

// OpenUSD uses the "primvar:" prefix for primvar namespacing, but it is not required in
// shading networks. Strip the substring to ensure correct primvar resolution.
void _PatchGeompropPrimvarPrefix(mx::DocumentPtr document)
{
  for (auto treeIt = document->traverseTree(); treeIt != mx::TreeIterator::end(); ++treeIt)
  {
    mx::ElementPtr elem = treeIt.getElement();

    mx::NodePtr node = elem->asA<mx::Node>();
    if (!node)
    {
      continue;
    }

    const mx::string& category = node->getCategory();
    if (category != "geompropvalue")
    {
      continue;
    }

    mx::InputPtr input = node->getActiveInput("geomprop");
    if (!input)
    {
      continue;
    }

    mx::ValuePtr value = input->getValue();
    if (!value || !value->isA<std::string>())
    {
      continue;
    }

    const static std::string PRIMVAR_PREFIX = "primvar:";

    std::string geomprop = value->asA<std::string>();

    if (geomprop.find(PRIMVAR_PREFIX) == 0)
    {
      std::string newGeomprop = geomprop.substr(PRIMVAR_PREFIX.length());
      input->setValue(newGeomprop);
    }
  }
}

// The MDL generator has some limitations when it comes to layering & mixing layers. This causes
// problems with the OpenPBR BXDFs and recent optimization changes to the glTF PBR & Standard Surface.
// To work around this, we ship our own implementations of these BXDFs.
// For more details, see this PR: https://github.com/AcademySoftwareFoundation/MaterialX/pull/2215
void _PatchStdLibBxdfs(mx::DocumentPtr lib, const mx::DocumentPtr customNodesDoc)
{
  const static std::unordered_set<std::string_view> BXDFS = {
#if MATERIALX_MAJOR_VERSION > 1 || \
    (MATERIALX_MAJOR_VERSION == 1 && MATERIALX_MINOR_VERSION > 39) || \
    (MATERIALX_MAJOR_VERSION == 1 && MATERIALX_MINOR_VERSION == 39 && MATERIALX_BUILD_VERSION > 3)
    "gltf_pbr",
    "standard_surface",
#endif
    "open_pbr_surface"
  };

  for (mx::NodeDefPtr nd : lib->getNodeDefs())
  {
    const std::string& nodeName = nd->getNodeString();

    if (!BXDFS.contains(nodeName))
    {
      continue;
    }

    GB_DEBUG("patching {}", nodeName);

    lib->removeNodeDef(nd->getName());

    mx::InterfaceElementPtr impl = nd->getImplementation();
    if (!impl || !impl->isA<mx::NodeGraph>())
    {
      continue;
    }

    lib->removeNodeGraph(impl->getName());
  }

  lib->importLibrary(customNodesDoc);
}

namespace gtl
{
  McMtlxDocumentPatcher::McMtlxDocumentPatcher([[maybe_unused]] const mx::DocumentPtr mtlxStdLib, const std::string& customNodesPath)
  {
    mx::FileSearchPath bxdfFiles;

#if MATERIALX_MAJOR_VERSION > 1 || \
    (MATERIALX_MAJOR_VERSION == 1 && MATERIALX_MINOR_VERSION > 39) || \
    (MATERIALX_MAJOR_VERSION == 1 && MATERIALX_MINOR_VERSION == 39 && MATERIALX_BUILD_VERSION > 3)
    bxdfFiles.append("gltf_pbr.xml");
    bxdfFiles.append("standard_surface.xml");
#endif

#if MATERIALX_MAJOR_VERSION > 1 || (MATERIALX_MAJOR_VERSION == 1 && MATERIALX_MINOR_VERSION >= 39)
    bxdfFiles.append("open_pbr_surface.xml");
#elif MATERIALX_MAJOR_VERSION == 1 && MATERIALX_MINOR_VERSION == 38 && MATERIALX_BUILD_VERSION == 10
    // Detect MaterialX 1.38.10-OpenPBR version
    if (mtlxStdLib->getNodeGraph("NG_mx39_open_pbr_surface_surfaceshader") != nullptr)
    {
      bxdfFiles.append("open_pbr_surface_1_38.xml");
    }
#endif

    m_customNodesDoc = mx::createDocument();
    mx::loadLibraries(mx::FilePathVec{ customNodesPath }, bxdfFiles, m_customNodesDoc);
  }

  mx::DocumentPtr McMtlxDocumentPatcher::patch(const mx::DocumentPtr document)
  {
    mx::DocumentPtr docCopy = document->copy();

    _SanitizeFilePaths(docCopy);

    _PatchBoolValueMismatches(docCopy);

    _PatchColor3FloatMismatches(docCopy);

    if (!getenv(ENVVAR_DISABLE_USDUVTEXTURE_COLOR_SPACE_PATCHING))
    {
      _PatchUsdUVTextureColorSpaces(docCopy);
    }

    _PatchNodeNames(docCopy);

    // FIXME: we can't match nodes inside implementations due to a bug in MaterialX (also see HdGatlingMesh)
    // https://github.com/AcademySoftwareFoundation/MaterialX/issues/2117
#if 0
    for (mx::NodeGraphPtr graph : docCopy->getNodeGraphs())
    {
      if (graph->getActiveSourceUri() == docCopy->getSourceUri())
      {
        graph->flattenSubgraphs();
      }
    }
#endif

    _PatchSecondaryTexcoordIndices(docCopy);

    _PatchColorNodes(docCopy);

    _PatchDefaultGeomprops(docCopy);

    _PatchGeompropPrimvarPrefix(docCopy);

    _PatchStdLibBxdfs(docCopy, m_customNodesDoc);

    return docCopy;
  }
}
