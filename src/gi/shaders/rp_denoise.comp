#extension GL_GOOGLE_include_directive: require
#extension GL_EXT_shader_16bit_storage: require
#extension GL_EXT_shader_explicit_arithmetic_types_float16: require

#include "interface/rp_oidn.h"

layout (local_size_x = WG_SIZE_X, local_size_y = WG_SIZE_Y) in;

layout(binding = 0, std430) readonly buffer InputBuffer { float16_t inPixels[]; };
#ifdef OP_COPY_CHANNELS
layout(binding = 1, std430) writeonly buffer OutputBuffer { float outPixels[]; };
#else
layout(binding = 1, std430) writeonly buffer OutputBuffer { float16_t outPixels[]; };
#endif
layout(binding = 2, std430) readonly buffer TensorBuffer { float tensors[]; };
#ifdef OP_JOIN
layout(binding = 3, std430) readonly buffer InputBuffer2 { float16_t inPixels2[]; };
#endif

layout(push_constant) uniform PushConstantBlock { PushConstants PC; };

#define KERNEL_SIZE 3
#define KERNEL_SIZE_SQ (KERNEL_SIZE * KERNEL_SIZE)
#define KERNEL_BIAS (KERNEL_SIZE / 2)

void main()
{
  if (gl_GlobalInvocationID.x >= PC.imageWidth || gl_GlobalInvocationID.y >= PC.imageHeight)
    return;

  int pixelIdx = int(gl_GlobalInvocationID.y * PC.imageWidth + gl_GlobalInvocationID.x);

#ifdef OP_UPSAMPLE
  uint outIdx0 = uint(gl_GlobalInvocationID.x*2 + 0 + (gl_GlobalInvocationID.y*2 + 0) * PC.imageWidth*2) * OUT_CHANNEL_COUNT;
  uint outIdx1 = uint(gl_GlobalInvocationID.x*2 + 1 + (gl_GlobalInvocationID.y*2 + 0) * PC.imageWidth*2) * OUT_CHANNEL_COUNT;
  uint outIdx2 = uint(gl_GlobalInvocationID.x*2 + 0 + (gl_GlobalInvocationID.y*2 + 1) * PC.imageWidth*2) * OUT_CHANNEL_COUNT;
  uint outIdx3 = uint(gl_GlobalInvocationID.x*2 + 1 + (gl_GlobalInvocationID.y*2 + 1) * PC.imageWidth*2) * OUT_CHANNEL_COUNT;

  for (int i = 0; i < IN_CHANNEL_COUNT; i++) // same as OUT_CHANNEL_COUNT
  {
    float16_t f = inPixels[pixelIdx * IN_CHANNEL_COUNT + i];
    outPixels[outIdx0 + i] = f;
    outPixels[outIdx1 + i] = f;
    outPixels[outIdx2 + i] = f;
    outPixels[outIdx3 + i] = f;
  }
#endif
#ifdef OP_MAX_POOL
  uint inIdx0 = uint(gl_GlobalInvocationID.x*2+0 + (gl_GlobalInvocationID.y*2 + 0) * PC.imageWidth*2) * IN_CHANNEL_COUNT;
  uint inIdx1 = uint(gl_GlobalInvocationID.x*2+1 + (gl_GlobalInvocationID.y*2 + 0) * PC.imageWidth*2) * IN_CHANNEL_COUNT;
  uint inIdx2 = uint(gl_GlobalInvocationID.x*2+0 + (gl_GlobalInvocationID.y*2 + 1) * PC.imageWidth*2) * IN_CHANNEL_COUNT;
  uint inIdx3 = uint(gl_GlobalInvocationID.x*2+1 + (gl_GlobalInvocationID.y*2 + 1) * PC.imageWidth*2) * IN_CHANNEL_COUNT;

  for (int i = 0; i < OUT_CHANNEL_COUNT; i++) // same as IN_CHANNEL_COUNT
  {
    float16_t max1 = max(inPixels[inIdx0 + i], inPixels[inIdx1 + i]);
    float16_t max2 = max(inPixels[inIdx2 + i], inPixels[inIdx3 + i]);
    outPixels[pixelIdx * OUT_CHANNEL_COUNT + i] = max(max1, max2);
  }
#endif
#ifdef OP_CONVOLVE
  for (uint oc = 0; oc < OUT_CHANNEL_COUNT; oc++)
  {
    float16_t result = float16_t(0.0);

    for (uint i = 0; i < KERNEL_SIZE; i++)
    for (uint j = 0; j < KERNEL_SIZE; j++)
    {
      ivec2 coord = ivec2(gl_GlobalInvocationID.xy) + ivec2(i, j) - ivec2(KERNEL_BIAS);
      coord.x = max(0, min(coord.x, int(PC.imageWidth) - 1));
      coord.y = max(0, min(coord.y, int(PC.imageHeight) - 1));

      int coordIdx = int(coord.y * PC.imageWidth + coord.x);

      for (uint ic = 0; ic < IN_CHANNEL_COUNT; ic++)
      {
        uint inIndexIj = coordIdx * IN_CHANNEL_COUNT + ic;

        uint weightIndex = (oc * IN_CHANNEL_COUNT * KERNEL_SIZE_SQ) + (ic * KERNEL_SIZE_SQ) + (j * KERNEL_SIZE + i); // OIHW

        //uint weightIndex = (((j * 3 + i) * IN_CHANNEL_COUNT) + ic) * OUT_CHANNEL_COUNT + oc; // HWIO

        float16_t weight = float16_t(tensors[PC.weightOffset + weightIndex]);

        result += inPixels[inIndexIj] * weight;
      }
    }

    result += float16_t(tensors[PC.biasOffset + oc]);

    result = max(result, float16_t(0.0)); // ReLU activation

    outPixels[pixelIdx * OUT_CHANNEL_COUNT + oc] = result;
  }
#endif
#ifdef OP_COPY_CHANNELS
  for (int i = 0; i < OUT_CHANNEL_COUNT; i++)
  {
    float f = (i < IN_CHANNEL_COUNT) ? float(inPixels[pixelIdx * IN_CHANNEL_COUNT + i]) : 0.0;
    outPixels[pixelIdx * OUT_CHANNEL_COUNT + i] = f;
  }
#endif
#ifdef OP_JOIN
  const uint RES_CHANNEL_COUNT = OUT_CHANNEL_COUNT + IN_CHANNEL_COUNT;

  for (int i = 0; i < IN_CHANNEL_COUNT; i++)
  {
    outPixels[pixelIdx * RES_CHANNEL_COUNT + i] = inPixels[pixelIdx * IN_CHANNEL_COUNT + i];
  }
  for (int i = 0; i < OUT_CHANNEL_COUNT; i++)
  {
    outPixels[pixelIdx * RES_CHANNEL_COUNT + IN_CHANNEL_COUNT + i] = inPixels2[pixelIdx * OUT_CHANNEL_COUNT + i];
  }
#endif
}
