#extension GL_GOOGLE_include_directive: require
#extension GL_EXT_shader_16bit_storage: require

#include "interface/rp_oidn.h"

layout (local_size_x = WG_SIZE_X, local_size_y = WG_SIZE_Y) in;

layout(binding = 0, std430) readonly buffer InputBuffer { float inPixels[]; };
layout(binding = 1, std430) writeonly buffer OutputBuffer { float outPixels[]; };
layout(binding = 2, std430) readonly buffer WeightsBuffer { float16_t weights[]; };

layout(push_constant) uniform PushConstantBlock { PushConstants PC; };

// TODO: expose input later width as DEFINE (3 vs 9)
// TODO: hardcode only color layer for now

void main()
{
  if (gl_GlobalInvocationID.x >= PC.imageWidth || gl_GlobalInvocationID.y >= PC.imageHeight)
    return;

  int inIdx = int(gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * PC.imageWidth) * 9;
  int outIdx = int(gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * PC.imageWidth) * 4;

#if 0 // viz input channels
  int channelOffset = 6; // 3 = normals, 6 = albedo
  for (int i = 0; i < 3; i++)
    outPixels[outIdx + i] = inPixels[inIdx + channelOffset + i];
#elif 0 // upsample
  if (gl_GlobalInvocationID.x >= (PC.imageWidth / 2) || gl_GlobalInvocationID.y >= (PC.imageHeight / 2))
    return;

  int outIdx0 = int(gl_GlobalInvocationID.x*2 + 0 + (gl_GlobalInvocationID.y*2 + 0) * PC.imageWidth) * 4;
  int outIdx1 = int(gl_GlobalInvocationID.x*2 + 1 + (gl_GlobalInvocationID.y*2 + 0) * PC.imageWidth) * 4;
  int outIdx2 = int(gl_GlobalInvocationID.x*2 + 0 + (gl_GlobalInvocationID.y*2 + 1) * PC.imageWidth) * 4;
  int outIdx3 = int(gl_GlobalInvocationID.x*2 + 1 + (gl_GlobalInvocationID.y*2 + 1) * PC.imageWidth) * 4;

  for (int i = 0; i < 3; i++)
  {
    outPixels[outIdx0 + i] = inPixels[inIdx + i];
    outPixels[outIdx1 + i] = inPixels[inIdx + i];
    outPixels[outIdx2 + i] = inPixels[inIdx + i];
    outPixels[outIdx3 + i] = inPixels[inIdx + i];
  }
#elif 0 // downsample
  if (gl_GlobalInvocationID.x >= (PC.imageWidth / 2) || gl_GlobalInvocationID.y >= (PC.imageHeight / 2))
    return;

  int inIdx0 = int(gl_GlobalInvocationID.x*2+0 + (gl_GlobalInvocationID.y*2 + 0) * PC.imageWidth) * 9;
  int inIdx1 = int(gl_GlobalInvocationID.x*2+1 + (gl_GlobalInvocationID.y*2 + 0) * PC.imageWidth) * 9;
  int inIdx2 = int(gl_GlobalInvocationID.x*2+0 + (gl_GlobalInvocationID.y*2 + 1) * PC.imageWidth) * 9;
  int inIdx3 = int(gl_GlobalInvocationID.x*2+1 + (gl_GlobalInvocationID.y*2 + 1) * PC.imageWidth) * 9;

  for (int i = 0; i < 3; i++)
    outPixels[outIdx + i] = (inPixels[inIdx0 + i] + inPixels[inIdx1 + i] + inPixels[inIdx2 + i] + inPixels[inIdx3 + i]) * 0.25;
#else // convolution

#define KERNEL_SIZE 3

  for (int k = 0; k < 3/*channels*/; k++)
  {
    float result = 0.0;

    for (int i = 0; i < KERNEL_SIZE; i++)
    for (int j = 0; j < KERNEL_SIZE; j++)
    {
      ivec2 coord = ivec2(gl_GlobalInvocationID.xy) + ivec2(i, j) - ivec2(KERNEL_SIZE/2);
      coord.x = max(0, min(coord.x, int(PC.imageWidth) - 1));
      coord.y = max(0, min(coord.y, int(PC.imageHeight) - 1));

      int inIndexIj = int(coord.x + coord.y * PC.imageWidth) * 9 + k;

      float s = inPixels[inIndexIj];
      float w = float(weights[PC.weightsOffset + i + j * KERNEL_SIZE]);

      result += s * w;
    }

    outPixels[outIdx + k] = abs(result);
  }
#endif
}
