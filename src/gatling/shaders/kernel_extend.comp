#version 450 core

#include "extensions.glsl"
#include "common.glsl"

layout(local_size_x_id = 0, local_size_y = 1, local_size_z = 1) in;
layout(constant_id = 1) const uint SAMPLE_COUNT = 1;
layout(constant_id = 2) const uint IMAGE_WIDTH = 3840;
layout(constant_id = 3) const uint IMAGE_HEIGHT = 2160;
layout(constant_id = 4) const uint MAX_STACK_SIZE = 6;
layout(constant_id = 5) const uint MAX_SM_STACK_SIZE = 12;

const float TRI_EPS = 0.0000001;

/* MÃ¶ller-Trumbore triangle intersection. */
bool test_face(
    in const path_segment ray,
    in const float t_max,
    in const uint face_index,
    out float t,
    out vec2 bc)
{
    const face f = faces[face_index];
    const vec3 p0 = vertices[f.v_0].field1.xyz;
    const vec3 p1 = vertices[f.v_1].field1.xyz;
    const vec3 p2 = vertices[f.v_2].field1.xyz;
    const vec3 e1 = p1 - p0;
    const vec3 e2 = p2 - p0;

    const vec3 p = cross(ray.dir, e2);
    const float det = dot(e1, p);

    if (abs(det) < TRI_EPS) {
        return false;
    }

    const float inv_det = 1.0 / det;
    const vec3 tvec = ray.origin - p0;

    bc.x = dot(tvec, p) * inv_det;
    if (bc.x < 0.0 || bc.x > 1.0) {
        return false;
    }

    const vec3 q = cross(tvec, e1);
    bc.y = dot(ray.dir, q) * inv_det;
    if (bc.y < 0.0 || (bc.x + bc.y > 1.0)) {
        return false;
    }

    t = dot(e2, q) * inv_det;

    if (t <= 0.0 || t >= t_max) {
        return false;
    }

    return true;
}

uint sign_to_byte_mask4(uint a)
{
    a = a & 0x80808080;
    a = a + a - (a >> 7);
    return a;
}

uint extract_byte(uint num, uint byte_idx)
{
    return (num >> (byte_idx * 8)) & 0xFF;
}

/* Unfortunately, we can't use gl_WorkGroupSize.x until
 * https://github.com/KhronosGroup/glslang/issues/1916
 * is fixed. */
shared uvec2 sm_stack[32][MAX_SM_STACK_SIZE];

uvec2 stack[MAX_STACK_SIZE];
uint stack_size = 0;

void stack_push(uvec2 group)
{
    if (stack_size < MAX_SM_STACK_SIZE) {
        sm_stack[gl_LocalInvocationID.x][stack_size] = group;
    }
    else {
        stack[stack_size - MAX_SM_STACK_SIZE] = group;
    }
    stack_size++;
}

uvec2 stack_pop()
{
    stack_size--;
    if (stack_size < MAX_SM_STACK_SIZE) {
        return sm_stack[gl_LocalInvocationID.x][stack_size];
    }
    else {
        return stack[stack_size - MAX_SM_STACK_SIZE];
    }
}

void traverse_bvh(in const uint ray_index)
{
    const path_segment ray = path_segments[ray_index];

    float t_max = FLOAT_MAX;
    float t_min = 0.0;
    const vec3 inv_dir = 1.0 / ray.dir;

    const uvec3 oct_inv = mix(uvec3(0), uvec3(4, 2, 1), greaterThanEqual(ray.dir, vec3(0.0)));
    const uint oct_inv4 = (oct_inv.x | oct_inv.y | oct_inv.z) * 0x01010101;

    vec2 hit_bc;
    uint hit_face_idx;

    uvec2 node_group = uvec2(0, 0x80000000);

    while (true)
    {
        uvec2 face_group = uvec2(0, 0);

        if (node_group.y <= 0x00FFFFFF)
        {
            face_group = node_group;
            node_group = uvec2(0, 0);
        }
        else
        {
            const uint child_bit_idx = findMSB(node_group.y);
            const uint slot_index = (child_bit_idx - 24) ^ (oct_inv4 & 0xFF);
            const uint rel_idx = bitCount(node_group.y & ~(0xFFFFFFFF << slot_index));
            const uint child_node_idx = node_group.x + rel_idx;

            node_group.y &= ~(1 << child_bit_idx);

            if (node_group.y > 0x00FFFFFF)
            {
                stack_push(node_group);
            }

            const bvh_node node = bvh_nodes[child_node_idx];

            node_group.x = node.child_index;
            face_group = uvec2(node.face_index, 0);

            const vec3 local_inv_dir = uintBitsToFloat(uvec3(node.e) << 23) * inv_dir;
            const vec3 local_orig = (node.p - ray.origin) * inv_dir;

            uint hitmask = 0;

            [[unroll, dependency_infinite]]
            for (uint passIdx = 0; passIdx < 2; ++passIdx)
            {
                const uint meta4 = node.meta[passIdx];
                const uint is_inner4 = (meta4 & (meta4 << 1)) & 0x10101010;
                const uint inner_mask4 = sign_to_byte_mask4(is_inner4 << 3);
                const uint bit_index4 = (meta4 ^ (oct_inv4 & inner_mask4)) & 0x1F1F1F1F;
                const uint child_bits4 = (meta4 >> 5) & 0x07070707;

                const vec4 x_gt_0 = vec4(inv_dir.x < 0.0);
                const vec4 y_gt_0 = vec4(inv_dir.y < 0.0);
                const vec4 z_gt_0 = vec4(inv_dir.z < 0.0);

                const u8vec4 q_lo_x = node.q_lo_x[passIdx];
                const u8vec4 q_hi_x = node.q_hi_x[passIdx];
                const u8vec4 q_lo_y = node.q_lo_y[passIdx];
                const u8vec4 q_hi_y = node.q_hi_y[passIdx];
                const u8vec4 q_lo_z = node.q_lo_z[passIdx];
                const u8vec4 q_hi_z = node.q_hi_z[passIdx];

                const vec4 s_q_lo_x = mix(q_lo_x, q_hi_x, x_gt_0);
                const vec4 s_q_hi_x = mix(q_hi_x, q_lo_x, x_gt_0);
                const vec4 s_q_lo_y = mix(q_lo_y, q_hi_y, y_gt_0);
                const vec4 s_q_hi_y = mix(q_hi_y, q_lo_y, y_gt_0);
                const vec4 s_q_lo_z = mix(q_lo_z, q_hi_z, z_gt_0);
                const vec4 s_q_hi_z = mix(q_hi_z, q_lo_z, z_gt_0);

                const vec4 t_min_x = local_inv_dir.x * s_q_lo_x + local_orig.x;
                const vec4 t_max_x = local_inv_dir.x * s_q_hi_x + local_orig.x;
                const vec4 t_min_y = local_inv_dir.y * s_q_lo_y + local_orig.y;
                const vec4 t_max_y = local_inv_dir.y * s_q_hi_y + local_orig.y;
                const vec4 t_min_z = local_inv_dir.z * s_q_lo_z + local_orig.z;
                const vec4 t_max_z = local_inv_dir.z * s_q_hi_z + local_orig.z;

                [[unroll, dependency_infinite]]
                for (uint child_idx = 0; child_idx < 4; ++child_idx)
                {
                    const float bmin = max(max(t_min_x[child_idx], t_min_y[child_idx]), max(t_min_z[child_idx], t_min));
                    const float bmax = min(min(t_max_x[child_idx], t_max_y[child_idx]), min(t_max_z[child_idx], t_max));

                    const bool is_intersected = bmin <= bmax;

                    if (!is_intersected) {
                        continue;
                    }

                    const uint child_bits = extract_byte(child_bits4, child_idx);
                    const uint bit_index = extract_byte(bit_index4, child_idx);
                    hitmask |= (child_bits << bit_index);
                }
            }

            node_group.y = (hitmask & 0xFF000000) | node.imask;
            face_group.y = (hitmask & 0x00FFFFFF);
        }

        const uint num_threads = subgroupBallotBitCount(subgroupBallot(true));

        while (face_group.y != 0)
        {
            const float R_t = 0.2;
            const uint threshold = uint(num_threads * R_t);

            const uint num_active_threads = subgroupBallotBitCount(subgroupBallot(true));

            if (num_active_threads < threshold)
            {
                stack_push(face_group);
                break;
            }

            const uint face_rel_index = findMSB(face_group.y);

            face_group.y &= ~(1 << face_rel_index);

            const uint face_index = face_group.x + face_rel_index;

            float temp_t;
            vec2 temp_bc;

            const bool has_hit = test_face(
                ray,
                t_max,
                face_index,
                temp_t,
                temp_bc
            );

            if (has_hit)
            {
                t_max = temp_t;
                hit_bc = temp_bc;
                hit_face_idx = face_index;
            }
        }

        if (node_group.y > 0x00FFFFFF) {
            continue;
        }

        if (stack_size > 0)
        {
            node_group = stack_pop();
            continue;
        }

        if (t_max != FLOAT_MAX)
        {
            const uint hit_index = atomicAdd(hit_write_counter, 1);

            hit_info hit;
            hit.pos = vec4(ray.origin + ray.dir * t_max, 1.0);
            hit.face_index = hit_face_idx;
            hit.bc = hit_bc;
            hit.pixel_index = ray.pixel_index;
            hits[hit_index] = hit;
        }

        return;
    }
}

void main()
{
    const uint TOTAL_RAY_COUNT = IMAGE_WIDTH * IMAGE_HEIGHT * SAMPLE_COUNT;

    while(true)
    {
      const uint ray_index = atomicAdd(path_segment_counter, 1);

      if (ray_index >= TOTAL_RAY_COUNT)
      {
        return;
      }

      traverse_bvh(ray_index);
    }
}
